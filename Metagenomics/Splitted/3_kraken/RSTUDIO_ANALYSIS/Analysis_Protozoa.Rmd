---
title: "Analysis"
author: "Oriol Castellano"
output: html_document
---

```{r}
# Load required libraries
library(dplyr)
library(ggplot2)
library(stringr)
library(dplyr)
# BiocManager::install("phyloseq")
library(phyloseq)
library(vegan) # Alpha and beta diversity
library(tidyr)
library(amap) # dendogram
library(ctc) # convert to newick
library(dendextend) # colour dend
library(purrr)
library(pheatmap)


#Load data
data <- read.csv("/home/uriii/Desktop/BIOINFORMATICS/INT_FDG/ANALYSIS/DATA/Metagenomics/KRAKEN/PROTOZOA/DATA_PROTOZOA.csv") # metadata + kraken_data
# MAYBE I HAVE TO SET "D55" == "D49"

metadata <- read.csv("/home/uriii/Desktop/BIOINFORMATICS/INT_FDG/ANALYSIS/DATA/Metagenomics/KRAKEN/PROTOZOA/metadata_PROTOZOA.csv")
kraken_data <- read.csv("/home/uriii/Desktop/BIOINFORMATICS/INT_FDG/ANALYSIS/DATA/Metagenomics/KRAKEN/PROTOZOA/report_data_PROTOZOA.csv")

data$Day[data$Day == "55"] <- "49"

data <- data[data$Taxon_name != "unclassified", ]
data <- data[data$Taxon_name != "root", ]
cellular_organisms <- data[data$Taxon_name == "cellularorganisms", ]

protozoa <- data[data$Taxon_name == "Eukaryota", ] # D
protozoa <- unique(protozoa)
protozoa <- na.omit(protozoa)
mprotozoa <- mean(protozoa$Percent)
mprotozoa

data <- data[data$Taxon_name != "Eukaryota", ]
data <- data[data$Taxon_name != "cellularorganisms", ]
data <- unique(data)
```

```{r}
mprotozoa <- mean(protozoa$Percent)
mprotozoa
```



# Alpha diversity
BETWEEN SAMPLES
```{r}
# IN ALL THE DATA -- BETWEEN SAMPLES
data_alpha <- data[, c(1, 11, 15)]

# Aggregate the values (summing counts for duplicate combinations --> I lose some samples due to this)
aggregated_data <- aggregate(Count ~ Sample + Taxon_name, data = data_alpha, sum)

# Pivot the data to wide format
wide_data <- spread(aggregated_data, Taxon_name, Count)

# Remove row names and set 'Sample' as a separate column
# wide_data <- data.frame(Sample = rownames(wide_data), wide_data)

# Replace NAs with 0
wide_data[is.na(wide_data)] <- 0

# Extract 'Sample' as row names
rownames(wide_data) <- wide_data$Sample
wide_data <- wide_data[, -1]
# wide_data$Sample.1 <- NULL

# Calculate alpha diversity (Shannon index) on WIDE DATA
alpha_div_w <- diversity(wide_data, index = "shannon")
summary(alpha_div_w)
alpha_div_w <- as.data.frame(alpha_div_w)
alpha_div_w$Samples <- rownames(alpha_div_w)

# data_alphadiv_w <- cbind(alpha_div_w, wide_data) # combine Alpha diversity indices 
kruskal1 <- kruskal.test(alpha_div_w$alpha_div_w ~ alpha_div_w$Samples) # Kruskal-Wallis
# print(kruskal1) # the p-value is 0.4726, which is greater than 0.05 == is no significant difference in Shannon diversity between SAMPLES, based on the Kruskal-Wallis Test
```

BETWEEN GROUPS
```{r}
process_group <- function(group_data) {
  # Aggregate the values
  aggregated_group <- group_data %>%
    group_by(Sample, Taxon_name) %>%
    summarise(Count = sum(Count)) %>%
    ungroup()

  # Pivot the data to wide format
  wide_group <- spread(aggregated_group, Taxon_name, Count, fill = 0)

  # Calculate alpha diversity (Shannon index)
  alpha_group <- diversity(wide_group[, -1], index = "shannon")

  # Combine alpha diversity indices with wide data
  data_alpha_group <- cbind(alpha_group, wide_group)

  return(data_alpha_group)
}

# Using purrr to process each group
alpha_div_results <- data %>%
  group_split(Group) %>%
  map(process_group)

# Combine the results into a single dataset
alpha_div_dataset <- bind_rows(alpha_div_results, .id = "Group")
alpha_div_dataset[is.na(alpha_div_dataset)] <- 0
# group 1 = NTS_IP, group 2 = NTS_NTP, group 3 = NTS_TP, group 4 = TS_IP, group 5 = TS_NTP # alpha_div_dataset$Group[alpha_div_dataset$Group == "1"] <- "NTS_IP"    # SO SLOW

alpha_div_dataset <- alpha_div_dataset %>%
  rename(alpha_div = alpha_group) %>%
  mutate(Group = case_when(
    Group == "1" ~ "NTS_IP",
    Group == "2" ~ "NTS_NTP",
    Group == "3" ~ "NTS_TP",
    Group == "4" ~ "TS_IP",
    Group == "5" ~ "TS_NTP",
    TRUE ~ as.character(Group) # Keep other values as is
  ))

# Define the custom order
custom_order <- c("NTS_NTP", "TS_NTP", "NTS_TP", "NTS_IP", "TS_IP")

# Convert the 'Group' variable to a factor with the custom order, just to change the order in the boxplot
alpha_div_dataset$Group <- factor(alpha_div_dataset$Group, levels = custom_order)

# BOXPLOT
ggplot(alpha_div_dataset, aes(x = Group, y = alpha_div, fill = Group)) +
  geom_boxplot() +
  labs(title = "Alpha diversity (Shannon index) at different groups", x = "Groups", y = "Shannon Diversity") +
  scale_fill_manual(name = "Group", values = c("green", "orange", "red", "blue", "purple")) + # ADJUST MANUALLY
  theme_classic()

kruskal2 <- kruskal.test(alpha_div_dataset$alpha_div ~ alpha_div_dataset$Group)
print(kruskal2) # the p-value is 0.118, which is greater than 0.05 == is no significant difference in Shannon diversity between groups based on the Kruskal-Wallis test. 
```
# Beta diversity
Between samples
```{r}
# Beta diversity analysis
dist_matrix <- vegdist(wide_data, method = "bray")
print(dist_matrix)
write.table(dist_matrix, file = "bray_curtis_matrix.txt", sep = "\t", quote = FALSE)

# PCoA -- Multidimensional scaling (MDS) is a means of visualizing the level of similarity of individual cases of a dataset.
pcoa_result <- cmdscale(dist_matrix)  #  is similar in spirit to PCA but it takes a dissimilarity as input! A dissimilarity matrix shows the distance between every possible pair of objects.

# color by sample
pcoa_result <- as.data.frame(pcoa_result)
pcoa_result$Sample <- rownames(pcoa_result)
data_pcoa <- metadata[, c(1,2,6)]
pcoa <- merge(pcoa_result, data_pcoa, by = c("Sample"), all.x = TRUE)
pcoa$Day <- factor(pcoa$Day) ###########################################################
pcoa$Day[pcoa$Day == "55"] <- "49"

ggplot(data = pcoa, aes(x = pcoa[, 2], y = pcoa[, 3])) +
  geom_point(aes(col = Day, shape = Group)) + 
  labs(title = "PCoA Plot - Days", x = "PC1", y = "PC2", color = "Extraction Day") +
  scale_color_manual(name = "Day", values = c("blue", "red"),  labels = c("49", "21")) + # values = color_vector,
  theme_classic() 
  # stat_ellipse(aes(col = Day))
```
```{r}
pcoa_day21 <- pcoa %>%
  filter(Day %in% "21")
ggplot(data = pcoa_day21, aes(x = pcoa_day21[, 2], y = pcoa_day21[, 3], col = Group)) +
  geom_point(aes(col = Group)) + 
  labs(title = "PCoA Plot - Day 21", x = "PC1", y = "PC2", color = "Group") +
  scale_color_manual(name = "Group", values = c("blue", "green", "red", "purple", "orange")) + # values = color_vector,
  scale_fill_manual(name = "Group", values = c("blue", "green", "red", "purple", "orange")) + # values = color_vector,
  theme_classic() + 
  stat_ellipse(geom = "polygon", aes(fill = Group), alpha = 0.1) # Instead of 

pcoa_day49 <- pcoa %>%
  filter(Day %in% "49")
ggplot(data = pcoa_day49, aes(x = pcoa_day49[, 2], y = pcoa_day49[, 3], col = Group)) +
  geom_point(aes(col = Group)) + 
  labs(title = "PCoA Plot - Day 49", x = "PC1", y = "PC2", color = "Group") +
  scale_color_manual(name = "Group", values = c("blue", "green", "red", "purple", "orange")) + # values = color_vector,
  scale_fill_manual(name = "Group", values = c("blue", "green", "red", "purple", "orange")) + # values = color_vector,
  theme_classic() + 
  stat_ellipse(geom = "polygon", aes(fill = Group), alpha = 0.1) # if I remove the fill from aes(), disappear from the legend --> I want this bit filling by colour to

```

```{r}
# Divide the previous PCoA by group
# Plot PCoA for Day 21, faceted by Group
ggplot(data = pcoa_day21, aes(x = pcoa_day21[, 2], y = pcoa_day21[, 3], col = Group)) +
  geom_point() +
  labs(title = "PCoA Plot - Day 21", x = "PC1", y = "PC2", color = "Group") +
  scale_color_manual(name = "Group", values = c("blue", "green", "red", "purple", "orange")) +
  facet_wrap(~Group) +
  theme_classic() +
  stat_ellipse(geom = "polygon", aes(fill = Group), alpha = 0.1)


# Plot PCoA for Day 49, faceted by Group
ggplot(data = pcoa_day49, aes(x = pcoa_day49[, 2], y = pcoa_day49[, 3], col = Group)) +
  geom_point() +
  labs(title = "PCoA Plot - Day 49", x = "PC1", y = "PC2", color = "Group") +
  scale_color_manual(name = "Group", values = c("blue", "green", "red", "purple", "orange")) +
  facet_wrap(~Group) +
  theme_classic() +
  stat_ellipse(geom = "polygon", aes(fill = Group), alpha = 0.1)

```


```{r}
data_perm <- data[, c(1, 4)] # Group and sample
# for wide_data
perm_wide_data <- wide_data
perm_wide_data$Sample <- rownames(wide_data)
perm_wide_data <- merge(perm_wide_data, data_perm, by = c("Sample"), all.x = T) # merge to have also the group ######### BAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD
# perm_wide_data <- cbind(perm_wide_data, data_perm, by = c("Sample"), all.x = T) # merge to have also the group ######### BAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD

rownames(perm_wide_data) <- perm_wide_data$Samples # samples
perm_wide_data <- perm_wide_data[, -1]
perm_wide_data$Group <- as.numeric(factor(perm_wide_data$Group))

permanova <- adonis2(perm_wide_data ~ Group, data = perm_wide_data, method = "bray")
permanova # p = 0.001  --> SIMILAR?
```


# Heatmaps
```{r}
data_days <- data[, c(6, 10, 13, 15)] # NOW PERCENT. CHANGE TO COLUMN 11 TO USE COUNTS
rank_to_filter <- "S"
data_days <- data_days[data_days$Rank == rank_to_filter, ]

# Sum all Viruses that belong to the same day
# Aggregate the values
aggregated_data_days <- aggregate(Percent ~ Day + Taxon_name, data = data_days, sum)

# Pivot the data to wide format
wide_data_days <- spread(aggregated_data_days, Taxon_name, Percent)

# Replace NAs with 0
wide_data_days[is.na(wide_data_days)] <- 0

# Extract 'Day' as row names
rownames(wide_data_days) <- wide_data_days$Day
wide_data_days <- wide_data_days[, -1]
# wide_data_days$Day.1 <- NULL

# Now, to make a heatmap we ought to first transform the raw counts of reads to proportions within a sample
# wide_data_days <- wide_data_days/rowSums(wide_data_days) # NOT NECESSARY

# colorRampPalette is in the RColorBrewer package. This creates a colour palette that shades from light yellow to red in RGB space with 100 unique colours
scaleyellowred <- colorRampPalette(c("lightyellow", "red"), space = "rgb")(100)
# heatmap(as.matrix(prop_wide_data_days), Rowv = NA, Colv = NA, col = scaleyellowred)

# determine the maximum relative abundance for each column
maxab <- apply(wide_data_days, 2, max)

# remove the genera with less than 0.0001% as their maximum relative abundance
threshold <- 0.1
wide_data_days_filtered <- wide_data_days[, maxab >= threshold]

newnames <- lapply(
  colnames(wide_data_days_filtered),
  function(x) bquote(italic(.(x))))

# pheatmap(as.matrix(wide_data_days_filtered), col = scaleyellowred, margins = c(10, 3), labels_col = as.expression(newnames), main = "Heatmap - Day", angle_col = 45)

# Plot the heatmap using the filtered data
pheatmap(as.matrix(wide_data_days_filtered), col = scaleyellowred, margins = c(10, 3), 
         labels_col = as.expression(newnames), main = paste("Heatmap - Rank:", rank_to_filter), 
         angle_col = 45)
```

