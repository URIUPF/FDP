```{r}
# Load required libraries
library(dplyr)
library(ggplot2)
library(stringr)
library(dplyr)
library(phyloseq)
library(vegan) # Alpha and beta diversity
library(tidyr)
library(amap) # dendogram
library(ctc) # convert to newick
library(dendextend) # colour dend
library(purrr)
library(pheatmap)
library(qiime2R)
library(gt)
library(rbiom)
library(ecodist)
library(viridis)
library(hagis)

#Load data
data <- read.csv("/home/uriii/Desktop/BIOINFORMATICS/INT_FDG/ANALYSIS/DATA/Metagenomics/KRAKEN/VIRUS/--careful/DATA_R/DATA.csv") # metadata + kraken_data
# MAYBE I HAVE TO SET "D55" == "D49"

metadata <- read.csv("/home/uriii/Desktop/BIOINFORMATICS/INT_FDG/ANALYSIS/DATA/Metagenomics/KRAKEN/VIRUS/--careful/DATA_R/metadata.csv")
metadata <- unique(metadata)
kraken_data <- read.csv("/home/uriii/Desktop/BIOINFORMATICS/INT_FDG/ANALYSIS/DATA/Metagenomics/KRAKEN/VIRUS/--careful/DATA_R/report_data.csv")

data$Day[data$Day == "55"] <- "49"

data <- data[data$Taxon_name != "unclassified", ]
data <- data[data$Taxon_name != "root", ]
virus <- data[data$Taxon_name == "Viruses", ] # Dataframe only containing each sample % of Viruses 
virus <- unique(virus)
virus <- na.omit(virus)
mvirus <- mean(virus$Percent)
mvirus

data <- data[data$Taxon_name != "Viruses", ]
data <- unique(data)
```

```{r}
# mvirus <- 0.44125
# mbacteria <- 26.05792
# mfungi <- 0.153617
# mprotozoa <- 0.155625
# marchaea <- 0.4014894

categories <- c("Virus", "Bacteria", "Fungi", "Protozoa", "Archaea")
mean_values <- c(0.44125, 26.05792, 0.153617, 0.155625, 0.4014894)
# unclassified <- 72.7901

# Create a data frame with two columns
means <- data.frame(Category = categories, Mean_Value = mean_values)

# ggplot(means, aes(x = categories, y = mean_values, fill = categories)) +
#   geom_bar(stat = "identity") + 
#   theme_classic() +
#   theme(legend.position = "none") + 
#   # coord_polar(start = 0) +
#   # ylim(0, 26.05792)
```

```{r}
mean_percent_21 <- mean(virus$Percent[virus$Day == 21], na.rm = TRUE)
mean_percent_21
mean_percent_49 <- mean(virus$Percent[virus$Day == 49], na.rm = TRUE)
mean_percent_49
mean_all <- mean(virus$Percent)
mean_all
ggplot(virus, aes(x = Sample, y = Percent, fill = Day)) +
  geom_bar(stat = 'identity') +  # 'stack' for stacked bars
  geom_hline(aes(yintercept = mean_percent_21, color = "Mean D21"), linetype = "dashed") +
  geom_hline(aes(yintercept = mean_percent_49, color = "Mean D49"), linetype = "dashed") +
  labs(x = 'Sample', y = '% of Viruses') +
  theme_classic() + 
  scale_fill_viridis_d() + 
  scale_color_manual(name = "Mean", values = viridis(2, option = "B", begin = 0.2, end = 0.9), labels = c("D21", "D49")) +
  theme(axis.text.x = element_text(angle = 60, hjust = 1, size = 7)) + # legend.position = 'top'  theme(axis.text.x = element_text(angle = 90, hjust = 1), legend.position = 'top') +
  facet_grid(col = vars(Group), scales = 'free_x') 
```


# Alpha diversity
BETWEEN SAMPLES
```{r}
# IN ALL THE DATA -- BETWEEN SAMPLES
data_alpha <- data[, c(1, 11, 15)]

# Aggregate the values (summing counts for duplicate combinations --> I lose some samples due to this)
aggregated_data <- aggregate(Count ~ Sample + Taxon_name, data = data_alpha, sum)

# Pivot the data to wide format
wide_data <- spread(aggregated_data, Taxon_name, Count)

# Remove row names and set 'Sample' as a separate column
# wide_data <- data.frame(Sample = rownames(wide_data), wide_data)

# Replace NAs with 0
wide_data[is.na(wide_data)] <- 0

# Extract 'Sample' as row names
rownames(wide_data) <- wide_data$Sample
wide_data <- wide_data[, -1]
# wide_data$Sample.1 <- NULL

# Calculate alpha diversity (Shannon index) on WIDE DATA
alpha_div_w <- diversity(wide_data, index = "shannon")
summary(alpha_div_w)
alpha_div_w <- as.data.frame(alpha_div_w)
alpha_div_w$Samples <- rownames(alpha_div_w)

# data_alphadiv_w <- cbind(alpha_div_w, wide_data) # combine Alpha diversity indices 
kruskal1 <- kruskal.test(alpha_div_w$alpha_div_w ~ alpha_div_w$Samples) # Kruskal-Wallis
print(kruskal1) # the p-value is 0.4726, which is greater than 0.05 == is no significant difference in Shannon diversity between SAMPLES, based on the Kruskal-Wallis Test
```

BETWEEN GROUPS
```{r}
process_group <- function(group_data) {
  # Aggregate the values
  aggregated_group <- group_data %>%
    group_by(Sample, Taxon_name) %>%
    summarise(Count = sum(Count)) %>%
    ungroup()

  # Pivot the data to wide format
  wide_group <- spread(aggregated_group, Taxon_name, Count, fill = 0)

  # Calculate alpha diversity (Shannon index)
  alpha_group <- diversity(wide_group[, -1], index = "shannon")

  # Combine alpha diversity indices with wide data
  data_alpha_group <- cbind(alpha_group, wide_group)

  return(data_alpha_group)
}

# Using purrr to process each group
alpha_div_results <- data %>%
  group_split(Group) %>%
  map(process_group)

# Combine the results into a single dataset
alpha_div_dataset <- bind_rows(alpha_div_results, .id = "Group")
alpha_div_dataset[is.na(alpha_div_dataset)] <- 0
# group 1 = NTS_IP, group 2 = NTS_NTP, group 3 = NTS_TP, group 4 = TS_IP, group 5 = TS_NTP # alpha_div_dataset$Group[alpha_div_dataset$Group == "1"] <- "NTS_IP"    # SO SLOW

alpha_div_dataset <- alpha_div_dataset %>%
  rename(alpha_div = alpha_group) %>%
  mutate(Group = case_when(
    Group == "1" ~ "NTS_IP",
    Group == "2" ~ "NTS_NTP",
    Group == "3" ~ "NTS_TP",
    Group == "4" ~ "TS_IP",
    Group == "5" ~ "TS_NTP",
    TRUE ~ as.character(Group) # Keep other values as is
  ))

# Define the custom order
custom_order <- c("NTS_NTP", "TS_NTP", "NTS_TP", "NTS_IP", "TS_IP")

# Convert the 'Group' variable to a factor with the custom order, just to change the order in the boxplot
alpha_div_dataset$Group <- factor(alpha_div_dataset$Group, levels = custom_order)

# BOXPLOT
ggplot(alpha_div_dataset, aes(x = Group, y = alpha_div, fill = Group)) +
  geom_boxplot() +
  labs(title = "Alpha diversity (Shannon index) at different groups", x = "Groups", y = "Shannon Diversity") +
  scale_fill_manual(name = "Group", values = c("green", "orange", "red", "blue", "purple")) + # ADJUST MANUALLY
  theme_classic()

ggplot(alpha_div_dataset, aes(y = alpha_div, fill = Group)) +
  geom_boxplot() +  # 'stack' for stacked bars
  labs(x = 'Groups', y = 'Shannon Diversity') +
  theme_classic() + 
  scale_fill_viridis_d() + 
  # scale_fill_manual(name = "Group", values = c("green", "orange", "red", "blue", "purple")) + # values = color_vector,
  theme(axis.text.x = element_blank(), legend.position = 'none', axis.ticks.x = element_blank()) +
  facet_grid(col = vars(Group), scales = 'free_x')

kruskal2 <- kruskal.test(alpha_div_dataset$alpha_div ~ alpha_div_dataset$Group)
print(kruskal2) # the p-value is 0.4301, which is greater than 0.05 == is no significant difference in Shannon diversity between groups based on the Kruskal-Wallis test. 
```
USING ADJUSTED PERCENT
```{r}
# IN ALL THE DATA -- BETWEEN SAMPLES
data_alpha <- data[, c(1, 15, 17)]

# Aggregate the values (summing counts for duplicate combinations --> I lose some samples due to this)
aggregated_data <- aggregate(adjusted_percent ~ Sample + Taxon_name, data = data_alpha, sum)

# Pivot the data to wide format
wide_data <- spread(aggregated_data, Taxon_name, adjusted_percent)

# Remove row names and set 'Sample' as a separate column
# wide_data <- data.frame(Sample = rownames(wide_data), wide_data)

# Replace NAs with 0
wide_data[is.na(wide_data)] <- 0

# Extract 'Sample' as row names
rownames(wide_data) <- wide_data$Sample
wide_data <- wide_data[, -1]
# wide_data$Sample.1 <- NULL

# Calculate alpha diversity (Shannon index) on WIDE DATA
alpha_div_w <- diversity(wide_data, index = "shannon")
summary(alpha_div_w)
alpha_div_w <- as.data.frame(alpha_div_w)
alpha_div_w$Samples <- rownames(alpha_div_w)

# data_alphadiv_w <- cbind(alpha_div_w, wide_data) # combine Alpha diversity indices 
kruskal1 <- kruskal.test(alpha_div_w$alpha_div_w ~ alpha_div_w$Samples) # Kruskal-Wallis
print(kruskal1) # the p-value is 0.4726, which is greater than 0.05 == is no significant difference in Shannon diversity between SAMPLES, based on the Kruskal-Wallis Test

# -----------------------------------------------------

process_group <- function(group_data) {
  # Aggregate the values
  aggregated_group <- group_data %>%
    group_by(Sample, Taxon_name) %>%
    summarise(adjusted_percent = sum(adjusted_percent)) %>%
    ungroup()

  # Pivot the data to wide format
  wide_group <- spread(aggregated_group, Taxon_name, adjusted_percent, fill = 0)

  # Calculate alpha diversity (Shannon index)
  alpha_group <- diversity(wide_group[, -1], index = "shannon")

  # Combine alpha diversity indices with wide data
  data_alpha_group <- cbind(alpha_group, wide_group)

  return(data_alpha_group)
}

# Using purrr to process each group
alpha_div_results <- data %>%
  group_split(Group) %>%
  map(process_group)

# Combine the results into a single dataset
alpha_div_dataset <- bind_rows(alpha_div_results, .id = "Group")
alpha_div_dataset[is.na(alpha_div_dataset)] <- 0
# group 1 = NTS_IP, group 2 = NTS_NTP, group 3 = NTS_TP, group 4 = TS_IP, group 5 = TS_NTP # alpha_div_dataset$Group[alpha_div_dataset$Group == "1"] <- "NTS_IP"    # SO SLOW

alpha_div_dataset <- alpha_div_dataset %>%
  rename(alpha_div = alpha_group) %>%
  mutate(Group = case_when(
    Group == "1" ~ "NTS_IP",
    Group == "2" ~ "NTS_NTP",
    Group == "3" ~ "NTS_TP",
    Group == "4" ~ "TS_IP",
    Group == "5" ~ "TS_NTP",
    TRUE ~ as.character(Group) # Keep other values as is
  ))

# Define the custom order
custom_order <- c("NTS_NTP", "TS_NTP", "NTS_TP", "NTS_IP", "TS_IP")

# Convert the 'Group' variable to a factor with the custom order, just to change the order in the boxplot
alpha_div_dataset$Group <- factor(alpha_div_dataset$Group, levels = custom_order)

# BOXPLOT
ggplot(alpha_div_dataset, aes(x = Group, y = alpha_div, fill = Group)) +
  geom_boxplot() +
  labs(title = "Alpha diversity (Shannon index) at different groups", x = "Groups", y = "Shannon Diversity") +
  scale_fill_manual(name = "Group", values = c("green", "orange", "red", "blue", "purple")) + # ADJUST MANUALLY
  theme_classic()

kruskal2 <- kruskal.test(alpha_div_dataset$alpha_div ~ alpha_div_dataset$Group)
print(kruskal2) # the p-value is 0.4301, which is greater than 0.05 == is no significant difference in Shannon diversity between groups based on the Kruskal-Wallis test. 
# -----------------------------------------------------
```




# Beta diversity
Between samples
```{r}
# Beta diversity analysis
dist_matrix <- vegdist(wide_data, method = "bray")
print(dist_matrix)
# write.table(dist_matrix, file = "bray_curtis_matrix.txt", sep = "\t", quote = FALSE)

# PCoA -- Multidimensional scaling (MDS) is a means of visualizing the level of similarity of individual cases of a dataset.
pcoa_result <- cmdscale(dist_matrix)  #  is similar in spirit to PCA but it takes a dissimilarity as input! A dissimilarity matrix shows the distance between every possible pair of objects.

# color by sample
pcoa_result <- as.data.frame(pcoa_result)
pcoa_result$Sample <- rownames(pcoa_result)
data_pcoa <- metadata[, c(1,2,6)]
pcoa <- merge(pcoa_result, data_pcoa, by = c("Sample"), all.x = TRUE)
pcoa$Day <- factor(pcoa$Day) ###########################################################
pcoa$Day[pcoa$Day == "55"] <- "49"

ggplot(data = pcoa, aes(x = pcoa[, 2], y = pcoa[, 3])) +
  geom_point(aes(col = Day, shape = Group)) + 
  labs(title = "PCoA Plot - Days", x = "PC1", y = "PC2", color = "Extraction Day") +
  scale_color_manual(name = "Day", values = c("blue", "red"),  labels = c("49", "21")) + # values = color_vector,
  theme_classic() 
  # + stat_ellipse(aes(col = Day))

ggplot(data = pcoa, aes(x = pcoa[, 2], y = pcoa[, 3])) +
  geom_point(aes(col = Group, shape = Day)) + 
  labs(title = "PCoA Plot - Days", x = "PC1", y = "PC2", color = "Extraction Day") +
  # scale_color_manual(name = "Group", values = c("blue", "red"),  labels = c("49", "21")) + # values = color_vector,
  theme_classic() +
  stat_ellipse(aes(col = Group))
```
```{r}
pcoa_day21 <- pcoa %>%
  filter(Day %in% "21")
ggplot(data = pcoa_day21, aes(x = pcoa_day21[, 2], y = pcoa_day21[, 3], col = Group)) +
  geom_point(aes(col = Group)) + 
  labs(title = "PCoA Plot - Day 21", x = "PC1", y = "PC2", color = "Group") +
  scale_color_manual(name = "Group", values = c("blue", "green", "red", "purple", "orange")) + # values = color_vector,
  scale_fill_manual(name = "Group", values = c("blue", "green", "red", "purple", "orange")) + # values = color_vector,
  theme_classic() + 
  stat_ellipse(geom = "polygon", aes(fill = Group), alpha = 0.1) # Instead of 

pcoa_day49 <- pcoa %>%
  filter(Day %in% "49")
ggplot(data = pcoa_day49, aes(x = pcoa_day49[, 2], y = pcoa_day49[, 3], col = Group)) +
  geom_point(aes(col = Group)) + 
  labs(title = "PCoA Plot - Day 49", x = "PC1", y = "PC2", color = "Group") +
  scale_color_manual(name = "Group", values = c("blue", "green", "red", "purple", "orange")) + # values = color_vector,
  scale_fill_manual(name = "Group", values = c("blue", "green", "red", "purple", "orange")) + # values = color_vector,
  theme_classic() + 
  stat_ellipse(geom = "polygon", aes(fill = Group), alpha = 0.1) # if I remove the fill from aes(), disappear from the legend --> I want this bit filling by colour to
```
```{r}
group_order <- c("NTS_IP", "NTS_NTP", "NTS_TP", "TS_IP", "TS_NTP")
ggplot(data = pcoa, aes(x = pcoa[, 2], y = pcoa[, 3])) +
  geom_point(aes(col = Day, shape = Group)) + 
  labs(title = "PCoA Plot - Color DAYS, shape GROUPS", x = "PC1", y = "PC2", color = "Extraction Day") +
  scale_color_manual(name = "Day", values = c("blue", "red"),  labels = c("49", "21")) + # values = color_vector,
  theme_classic() 

ggplot(data = pcoa, aes(x = pcoa[, 2], y = pcoa[, 3])) +
  geom_point(aes(col = Group, shape = Day)) + 
  labs(title = "PCoA Plot - Groups color, days shape", x = "PC1", y = "PC2") +
  # scale_color_manual(name = "Group", values = c("blue", "red"),  labels = c("49", "21")) + # values = color_vector,
  theme_classic() +
  scale_color_viridis_d() +
  scale_fill_viridis_d() +
  stat_ellipse(geom = "polygon", aes(fill = Group), alpha = 0.1)

pcoa_day21$Group <- factor(pcoa_day21$Group, levels = group_order)
ggplot(data = pcoa_day49, aes(x = pcoa_day49[, 2], y = pcoa_day49[, 3], col = Group)) +
  geom_point(aes(col = Group)) + 
  labs(title = "PCoA Plot - Day 49 - Group Colors", x = "PC1", y = "PC2", color = "Group") +
  scale_color_viridis_d() +
  scale_fill_viridis_d() + 
  theme_classic() + 
  stat_ellipse(geom = "polygon", aes(fill = Group), alpha = 0.1) 

pcoa_day49$Group <- factor(pcoa_day49$Group, levels = group_order)
ggplot(data = pcoa_day49, aes(x = pcoa_day49[, 2], y = pcoa_day49[, 3], col = Group)) +
  geom_point(aes(col = Group)) + 
  labs(title = "PCoA Plot - Day 49", x = "PC1", y = "PC2", color = "Group") +
  scale_color_viridis_d() +
  scale_fill_viridis_d() + 
  theme_classic() + 
  stat_ellipse(geom = "polygon", aes(fill = Group), alpha = 0.1) 
```


```{r}
# Divide the previous PCoA by group
# Plot PCoA for Day 21, faceted by Group
# ggplot(data = pcoa_day21, aes(x = pcoa_day21[, 2], y = pcoa_day21[, 3], col = Group)) +
#   geom_point() +
#   labs(title = "PCoA Plot - Day 21", x = "PC1", y = "PC2", color = "Group") +
#   scale_color_manual(name = "Group", values = c("blue", "green", "red", "purple", "orange")) +
#   facet_wrap(~Group) +
#   theme_classic() +
#   stat_ellipse(geom = "polygon", aes(fill = Group), alpha = 0.1)
# 
# 
# # Plot PCoA for Day 49, faceted by Group
# ggplot(data = pcoa_day49, aes(x = pcoa_day49[, 2], y = pcoa_day49[, 3], col = Group)) +
#   geom_point() +
#   labs(title = "PCoA Plot - Day 49", x = "PC1", y = "PC2", color = "Group") +
#   scale_color_manual(name = "Group", values = c("blue", "green", "red", "purple", "orange")) +
#   facet_wrap(~Group) +
#   theme_classic() +
#   stat_ellipse(geom = "polygon", aes(fill = Group), alpha = 0.1)

```
```{r}
# dist_matrix <- vegdist(wide_data, method = "bray")
# # PCoA -- Multidimensional scaling (MDS) is a means of visualizing the level of similarity of individual cases of a dataset.
# bray_curtis_pcoa <- pco(dist_matrix)
# bray_curtis_pcoa_df <- data.frame(pcoa1 = bray_curtis_pcoa$vectors[,1], 
#                                   pcoa2 = bray_curtis_pcoa$vectors[,2])
# 
# ggplot(data = bray_curtis_pcoa_df, aes(x=pcoa1, y=pcoa2)) +
#   geom_point() +
#   labs(x = "PC1",
#        y = "PC2", 
#        title = "Bray-Curtis PCoA") +
#   theme(title = element_text(size = 10))
# 
# comm <- read.csv("~/Downloads/communities.csv", header=TRUE, sep=";")
# dist_matrix <- vegdist(comm, method = "bray")
# bray_curtis_pcoa <- pco(dist_matrix)
# bray_curtis_pcoa_df <- data.frame(pcoa1 = bray_curtis_pcoa$vectors[,1], 
#                                   pcoa2 = bray_curtis_pcoa$vectors[,2])
# ggplot(data = bray_curtis_pcoa_df, aes(x=pcoa1, y=pcoa2)) +
#   geom_point() +
#   labs(x = "PC1",
#        y = "PC2", 
#        title = "Bray-Curtis PCoA") +
#   theme(title = element_text(size = 10))
```


```{r}
data_perm <- data[, c(1, 4)] # Group and sample
# for wide_data
perm_wide_data <- wide_data
perm_wide_data$Sample <- rownames(wide_data)
perm_wide_data <- merge(perm_wide_data, data_perm, by = c("Sample")) # merge to have also the group ######### BAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD
# perm_wide_data <- cbind(perm_wide_data, data_perm, by = c("Sample"), all.x = T) # merge to have also the group ######### BAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD
perm_wide_data <- unique(perm_wide_data)

rownames(perm_wide_data) <- perm_wide_data$Sample # samples
perm_wide_data <- perm_wide_data[, -1]
perm_wide_data$Group <- as.numeric(factor(perm_wide_data$Group))

permanova_All <- adonis2(perm_wide_data ~ Group, data = perm_wide_data, method = "bray")
permanova_All # NO statistically significant similarities between groups



# OK
perm_result <- adonis2(dist_matrix ~ Group, data = metadata, permutations = 999)
# This performs the PERMANOVA test. Here, Group is the factor you want to test against (make sure Group is the correct column name in your metadata). The permutations = 999 argument specifies the number of permutations to use for the test.
```

```{r}
# DAY 21
data_perm <- data[, c(1, 4, 6)] # Group and sample
perm_wide_data <- wide_data
perm_wide_data$Sample <- rownames(wide_data)
perm_wide_data <- merge(perm_wide_data, data_perm, by = c("Sample")) # merge to have also the group
perm_wide_data <- unique(perm_wide_data)
perm_wide_data_21 <- perm_wide_data[perm_wide_data$Day == "21", ]
rownames(perm_wide_data_21) <- perm_wide_data_21$Sample # samples
perm_wide_data_21 <- perm_wide_data_21[, -1]
perm_wide_data_21 <- perm_wide_data_21[, -which(names(perm_wide_data_21) == "Day")]
perm_wide_data_21$Group <- as.numeric(factor(perm_wide_data_21$Group))

permanova_21 <- adonis2(perm_wide_data_21 ~ Group, data = perm_wide_data_21, method = "bray")
permanova_21 # p HIGHER than 0.05 -_> similarities between groups at day 21
```

```{r}
# DAY 49
data_perm <- data[, c(1, 4, 6)] # Group and sample
perm_wide_data <- wide_data
perm_wide_data$Sample <- rownames(wide_data)
perm_wide_data <- merge(perm_wide_data, data_perm, by = c("Sample")) # merge to have also the group ######### BAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD
perm_wide_data <- unique(perm_wide_data)
perm_wide_data_49 <- perm_wide_data[perm_wide_data$Day == "49", ]
rownames(perm_wide_data_49) <- perm_wide_data_49$Sample # samples
perm_wide_data_49 <- perm_wide_data_49[, -1]
perm_wide_data_49 <- perm_wide_data_49[, -which(names(perm_wide_data_49) == "Day")]
perm_wide_data_49$Group <- as.numeric(factor(perm_wide_data_49$Group))

permanova_49 <- adonis2(perm_wide_data_49 ~ Group, data = perm_wide_data_49, method = "bray")
permanova_49 # p < 0.05 --> statistically significant DIFFERENCES between groups at day 49
```



# Hierarchical clustering
Between samples
```{r}
# # Perform hierarchical clustering
hc <- hclust(dist_matrix)
dhc <- as.dendrogram(hc)
# hc2Newick(hc, flat=TRUE)

# Plot
dhc <- dhc %>%
  set("labels_cex", 0.7) %>% # size of the letters     
  set("labels_col", c(1,2,3)) %>%  # change color of the labels by cluster
  color_branches(k = 3) %>% #color branches
  set("branches_lwd", 2) %>% # grosor branches
  color_labels(dhc, k = 3) # colour the labels k = number of colors
plot(dhc,  main = "Hierarchical Clustering Dendrogram", xlab = "Samples", ylab = "Distance")

```


# Heatmaps
# for sample
```{r}
data_days <- data[, c(6, 11, 13, 15)]

```

# for day
```{r}
data_days <- data[, c(6, 11, 13, 15)]
rank_to_filter <- "S"
data_days <- data_days[data_days$Rank == rank_to_filter, ]

# Sum all Viruses that belong to the same day
# Aggregate the values (summing counts for duplicate combinations --> I lose some samples due to this)
aggregated_data_days <- aggregate(Count ~ Day + Taxon_name, data = data_days, sum)

# Pivot the data to wide format
wide_data_days <- spread(aggregated_data_days, Taxon_name, Count)

# Remove row names and set 'Day' as a separate column
# wide_data_days <- data.frame(Day = rownames(wide_data_days), wide_data_days)

# Replace NAs with 0
wide_data_days[is.na(wide_data_days)] <- 0

# Extract 'Day' as row names
rownames(wide_data_days) <- wide_data_days$Day
wide_data_days <- wide_data_days[, -1]
# wide_data_days$Day.1 <- NULL

# Now, to make a heatmap we ought to first transform the raw counts of reads to proportions within a sample
wide_data_days <- wide_data_days/rowSums(wide_data_days) # NOT NECESSARY

# colorRampPalette is in the RColorBrewer package. This creates a colour palette that shades from light yellow to red in RGB space with 100 unique colours
scaleyellowred <- colorRampPalette(c("lightyellow", "red"), space = "rgb")(100)
# heatmap(as.matrix(prop_wide_data_days), Rowv = NA, Colv = NA, col = scaleyellowred)

# determine the maximum relative abundance for each column
maxab <- apply(wide_data_days, 2, max)

# remove the genera with less than 0.0001% as their maximum relative abundance
threshold <- 0.01

wide_data_days_filtered <- wide_data_days[, maxab >= threshold]
# heatmap(as.matrix(prop_wide_data_days_filtered), Rowv = NA, Colv = NA, col = scaleyellowred, margins = c(10, 2))

newnames <- lapply(
  colnames(wide_data_days_filtered),
  function(x) bquote(italic(.(x))))

# pheatmap(as.matrix(wide_data_days_filtered), col = scaleyellowred, margins = c(10, 3), labels_col = as.expression(newnames), main = "Heatmap - Day", angle_col = 45)

# Plot the heatmap using the filtered data
pheatmap(as.matrix(wide_data_days_filtered), col = scaleyellowred, margins = c(10, 3), 
         labels_col = as.expression(newnames), main = paste("Heatmap - Rank:", rank_to_filter), 
         angle_col = 45)


#### BASED ON PERCENT
data_days <- data[, c(6, 10, 13, 15)] # NOW PERCENT. CHANGE TO COLUMN 11 TO USE COUNTS
rank_to_filter <- "S"
data_days <- data_days[data_days$Rank == rank_to_filter, ]

# Sum all Viruses that belong to the same day
# Aggregate the values
aggregated_data_days <- aggregate(Percent ~ Day + Taxon_name, data = data_days, sum)

# Pivot the data to wide format
wide_data_days <- spread(aggregated_data_days, Taxon_name, Percent)

# Replace NAs with 0
wide_data_days[is.na(wide_data_days)] <- 0

# Extract 'Day' as row names
rownames(wide_data_days) <- wide_data_days$Day
wide_data_days <- wide_data_days[, -1]
# wide_data_days$Day.1 <- NULL

# Now, to make a heatmap we ought to first transform the raw counts of reads to proportions within a sample
# wide_data_days <- wide_data_days/rowSums(wide_data_days) # NOT NECESSARY

# colorRampPalette is in the RColorBrewer package. This creates a colour palette that shades from light yellow to red in RGB space with 100 unique colours
scaleyellowred <- colorRampPalette(c("lightyellow", "red"), space = "rgb")(100)
# heatmap(as.matrix(prop_wide_data_days), Rowv = NA, Colv = NA, col = scaleyellowred)

# determine the maximum relative abundance for each column
maxab <- apply(wide_data_days, 2, max)

# remove the genera with less than 0.0001% as their maximum relative abundance
threshold <- 0.1
wide_data_days_filtered <- wide_data_days[, maxab >= threshold]

newnames <- lapply(
  colnames(wide_data_days_filtered),
  function(x) bquote(italic(.(x))))

# pheatmap(as.matrix(wide_data_days_filtered), col = scaleyellowred, margins = c(10, 3), labels_col = as.expression(newnames), main = "Heatmap - Day", angle_col = 45)

# Plot the heatmap using the filtered data
pheatmap(as.matrix(wide_data_days_filtered), col = scaleyellowred, margins = c(10, 3), 
         labels_col = as.expression(newnames), main = paste("Heatmap - Rank:", rank_to_filter), 
         angle_col = 45)
```


# Tests
Use Percent instead of count in wide data and perform bray curtis
```{r}
# IN ALL THE DATA -- BETWEEN SAMPLES
data_alpha <- data[, c(1, 10, 15)]

# Aggregate the values (summing counts for duplicate combinations --> I lose some samples due to this)
aggregated_data <- aggregate(Percent ~ Sample + Taxon_name, data = data_alpha, sum)

# Pivot the data to wide format
wide_data <- spread(aggregated_data, Taxon_name, Percent)

# Remove row names and set 'Sample' as a separate column
# wide_data <- data.frame(Sample = rownames(wide_data), wide_data)

# Replace NAs with 0
wide_data[is.na(wide_data)] <- 0

# Extract 'Sample' as row names
rownames(wide_data) <- wide_data$Sample
wide_data <- wide_data[, -1]
# wide_data$Sample.1 <- NULL

# Beta
dist_matrix <- vegdist(wide_data, method = "bray")
print(dist_matrix)
# write.table(dist_matrix, file = "bray_curtis_matrix.csv", quote = FALSE)

# PCoA -- Multidimensional scaling (MDS) is a means of visualizing the level of similarity of individual cases of a dataset.
pcoa_result <- cmdscale(dist_matrix)  #  is similar in spirit to PCA but it takes a dissimilarity as input! A dissimilarity matrix shows the distance between every possible pair of objects.

# color by sample
pcoa_result <- as.data.frame(pcoa_result)
pcoa_result$Sample <- rownames(pcoa_result)
data_pcoa <- metadata[, c(1,2,6)]
pcoa <- merge(pcoa_result, data_pcoa, by = c("Sample"), all.x = TRUE)
pcoa$Day <- factor(pcoa$Day) ###########################################################
pcoa$Day[pcoa$Day == "55"] <- "49"

ggplot(data = pcoa, aes(x = pcoa[, 2], y = pcoa[, 3])) +
  geom_point(aes(col = Day, shape = Group)) + 
  labs(title = "PCoA Plot - Days", x = "PC1", y = "PC2", color = "Extraction Day") +
  scale_color_manual(name = "Day", values = c("blue", "red"),  labels = c("49", "21")) + # values = color_vector,
  theme_classic() 
  # stat_ellipse(aes(col = Day))

```
USING ADJUSTED PERCENT
```{r}
# IN ALL THE DATA -- BETWEEN SAMPLES
data_alpha <- data[, c(1, 15, 17)]

# Aggregate the values (summing counts for duplicate combinations --> I lose some samples due to this)
aggregated_data <- aggregate(adjusted_percent ~ Sample + Taxon_name, data = data_alpha, sum)

# Pivot the data to wide format
wide_data <- spread(aggregated_data, Taxon_name, adjusted_percent)

# Remove row names and set 'Sample' as a separate column
# wide_data <- data.frame(Sample = rownames(wide_data), wide_data)

# Replace NAs with 0
wide_data[is.na(wide_data)] <- 0

# Extract 'Sample' as row names
rownames(wide_data) <- wide_data$Sample
wide_data <- wide_data[, -1]
# wide_data$Sample.1 <- NULL

# Beta
dist_matrix <- vegdist(wide_data, method = "bray")
print(dist_matrix)
# write.table(dist_matrix, file = "bray_curtis_matrix.csv", quote = FALSE)

# PCoA -- Multidimensional scaling (MDS) is a means of visualizing the level of similarity of individual cases of a dataset.
pcoa_result <- cmdscale(dist_matrix)  #  is similar in spirit to PCA but it takes a dissimilarity as input! A dissimilarity matrix shows the distance between every possible pair of objects.

# color by sample
pcoa_result <- as.data.frame(pcoa_result)
pcoa_result$Sample <- rownames(pcoa_result)
data_pcoa <- metadata[, c(1,2,6)]
pcoa <- merge(pcoa_result, data_pcoa, by = c("Sample"), all.x = TRUE)
pcoa$Day <- factor(pcoa$Day) ###########################################################
pcoa$Day[pcoa$Day == "55"] <- "49"

ggplot(data = pcoa, aes(x = pcoa[, 2], y = pcoa[, 3])) +
  geom_point(aes(col = Day, shape = Group)) + 
  labs(title = "PCoA Plot - Days", x = "PC1", y = "PC2", color = "Extraction Day") +
  scale_color_manual(name = "Day", values = c("blue", "red"),  labels = c("49", "21")) + # values = color_vector,
  theme_classic() 
  # stat_ellipse(aes(col = Day))

pcoa_day21 <- pcoa %>%
  filter(Day %in% "21")
ggplot(data = pcoa_day21, aes(x = pcoa_day21[, 2], y = pcoa_day21[, 3], col = Group)) +
  geom_point(aes(col = Group)) + 
  labs(title = "PCoA Plot - Day 21", x = "PC1", y = "PC2", color = "Group") +
  scale_color_manual(name = "Group", values = c("blue", "green", "red", "purple", "orange")) + # values = color_vector,
  scale_fill_manual(name = "Group", values = c("blue", "green", "red", "purple", "orange")) + # values = color_vector,
  theme_classic() + 
  stat_ellipse(geom = "polygon", aes(fill = Group), alpha = 0.1) # Instead of 

pcoa_day49 <- pcoa %>%
  filter(Day %in% "49")
ggplot(data = pcoa_day49, aes(x = pcoa_day49[, 2], y = pcoa_day49[, 3], col = Group)) +
  geom_point(aes(col = Group)) + 
  labs(title = "PCoA Plot - Day 49", x = "PC1", y = "PC2", color = "Group") +
  scale_color_manual(name = "Group", values = c("blue", "green", "red", "purple", "orange")) + # values = color_vector,
  scale_fill_manual(name = "Group", values = c("blue", "green", "red", "purple", "orange")) + # values = color_vector,
  theme_classic() + 
  stat_ellipse(geom = "polygon", aes(fill = Group), alpha = 0.1) # if I remove the fill from aes(), disappear from the legend --> I want this bit filling by colour to

```


EXAMPLE WITH ANOTHER DATASET
```{r}
# Create an example abundance table
taxa_names <- c("Taxon1", "Taxon2", "Taxon3", "Taxon4")
sample_names <- paste("Sample", 1:10, sep="")
abundance_table <- matrix(data = round(matrix(rpois(40, lambda = 10), ncol = 4), digits = 0), ncol = 4)

# Display the abundance table
print("Abundance Table:")
print(abundance_table)

# Beta diversity analysis using vegan package (Bray-Curtis dissimilarity in this case)
beta_diversity <- vegdist(abundance_table, method = "bray")

# Perform Non-metric Multidimensional Scaling (NMDS)
pcoa <- pco(beta_diversity)
bray_curtis_pcoa_df <- data.frame(pcoa1 = pcoa$vectors[,1], 
                                  pcoa2 = pcoa$vectors[,2])
ggplot(data = bray_curtis_pcoa_df, aes(x=pcoa1, y=pcoa2)) +
  geom_point() +
  labs(x = "PC1",
       y = "PC2", 
       title = "Bray-Curtis PCoA") +
  theme(title = element_text(size = 10))

# Assuming you have a grouping variable named 'group'
groups <- factor(c("Group1", "Group1", "Group1", "Group1", "Group1", "Group2", "Group2", "Group2", "Group2", "Group2"))

# Permanova
permanova_result <- adonis(beta_diversity ~ groups, permutations = 999)

# Display the Permanova results
print("Permanova Results:")
print(permanova_result)

########################
# Assuming your data is stored in a data frame named 'my_data'
my_data <- data.frame(
  V1 = c(1, 2, 3, 4, 5),
  V2 = c(17, 12, 15, 10, 12),
  V3 = c(9, 9, 7, 9, 11),
  V4 = c(8, 13, 15, 7, 8)
)

# Load the vegan package
library(vegan)

# Transpose the data frame because vegan expects samples in rows and species in columns
my_data_t <- t(my_data)

# Calculate Bray-Curtis dissimilarity matrix
bc_matrix <- vegdist(my_data_t, method = "bray")

# Print the matrix
print(bc_matrix)
```
